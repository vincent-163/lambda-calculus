Test=Type:* a:Type *
# Logic not
not=P:* T.* (.P T)

xx=
# The Peano axioms
Nat:*
Zero:Nat
Succ:.Nat Nat
Equal:(.Nat .Nat *)
EqualRfl: x.Nat (Equal x x)
EqualTrans: x.Nat y.Nat z.Nat .(Equal x y) .(Equal y z) (Equal x z)
SuccInj:x.Nat y.Nat .(Equal (Succ x) (Succ y)) (Equal x y)
SuccNeqZero:x.Nat (not (Equal (Succ x) Zero))
Induction:P.(.Nat *) .(P Zero) .(n.Nat (P (Succ n))) n.Nat (P n)

# For first order theory, plus and multiplication are added as axioms
Plus:(.Nat .Nat Nat)
PlusBase: n.Nat (Equal (Plus Zero n) n)
PlusSucc: a.Nat n.Nat (Equal (Plus (Succ a) n) (Plus a (Succ n)))
Mul:(.Nat .Nat Nat)
MulBase: n.Nat (Equal (Mul Zero n) n)
MulSucc: a.Nat n.Nat (Equal (Mul (Succ a) n) (Plus n (Mul (a n))))

# Prove 1+1=2!
One=(Succ Zero)
Two=(Succ (Succ Zero))
OnePlusOne=(Plus One One)

x_1p1e0p2=(PlusSucc Zero One)
#(Test (Equal (Plus One One) (Plus Zero Two)) x_1p1e0p2)
x_0p2e2=(PlusBase Two)
#(Test (Equal (Plus Zero Two) Two) x_0p2e2)

# the proof
OnePlusOneEqualsTwo=(EqualTrans (Plus One One) (Plus Zero Two) Two x_1p1e0p2 x_0p2e2)
(Test (Equal OnePlusOne Two) OnePlusOneEqualsTwo)


#test=(Test (Equal OnePlusOne Two) OnePlusOneEqualsTwo)
#test1=(Test Nat One)

xx